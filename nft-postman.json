{
	"info": {
		"_postman_id": "7ff4503e-e414-402e-9a87-9b89b4a9fc33",
		"name": "Freight Trust Non Fungible Documents of Trade",
		"description": " FT-This is the api reference for the Freight Trust dApp which allows recording, transfering and signing of documents of trade.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "nft",
			"item": [
				{
					"name": "Returns the token contract's name",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "579475a4-dc18-4d32-aac1-f93f79607164",
								"exec": [
									"pm.test(\"Returns the right name\", function () {",
									"    response = pm.response.json();",
									"    pm.expect(response[\"name\"]).to.eql(\"Documents of Trade\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/name",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"name"
							]
						}
					},
					"response": []
				},
				{
					"name": "Returns the token contract's symbol",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "d700d7ea-b3b2-4b09-b41d-0864ce4d107a",
								"exec": [
									"pm.test(\"Returns the right symbol\", function () {",
									"    response = pm.response.json();",
									"    pm.expect(response[\"symbol\"]).to.eql(\"DOT\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/symbol",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"symbol"
							]
						}
					},
					"response": []
				},
				{
					"name": "An API endpoint to get the total supply of tokens in the ERC721 contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "7a4ced55-4a8d-42ce-b3db-6d6b8da24ff1",
								"exec": [
									"pm.test(\"Returns the right type\", function () {",
									"    response = pm.response.json();",
									"    pm.expect(uintVerify(response[\"totalSupply\"])).to.eql(true);",
									"});",
									"",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665640564039457584007913129639935))",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/totalSupply",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"totalSupply"
							]
						},
						"description": "Returns the total supply of Non fungible tokens"
					},
					"response": []
				},
				{
					"name": "Returns the Token URI",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "f20a8058-89d6-457c-b611-276db0739470",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"tokenId\"), 32)){",
									"        pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof response[\"tokenURI\"]).to.eql(\"string\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/tokenURI/?tokenId={{tokenId}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"tokenURI",
								""
							],
							"query": [
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Returns an interface's support status",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "3d18a808-f86d-4934-ac6c-ca7fb9d46468",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"interfaceId\"), 4)){",
									"        pm.response.to.have.status(200);",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof response[\"supported\"]).to.eql(\"boolean\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/supportsInterface/?interfaceId={{interfaceId}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"supportsInterface",
								""
							],
							"query": [
								{
									"key": "interfaceId",
									"value": "{{interfaceId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Returns the token identifier of the `index`-th nft tracked by the contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "6b173a5a-2304-4c7c-8e52-d00829dafe1f",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"index\"), 32)) {",
									"        pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(uintVerify(response[\"token\"])).to.eql(true);",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/tokenByIndex/?index={{index}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"tokenByIndex",
								""
							],
							"query": [
								{
									"key": "index",
									"value": "{{index}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Returns the token identifier of the `index`-th nft assigned to the `owner`",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "9be24162-8042-4e9c-b8b3-41979e99dffd",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(uintVerify(pm.variables.get(\"index\"))){",
									"        if(bytesVerify(pm.variables.get(\"owner\"), 20)){",
									"          pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"        }",
									"        else{",
									"          pm.expect(pm.response.code).to.be.oneOf([400, 425]);  ",
									"        }",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(uintVerify(response[\"token\"])).to.eql(true);",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/tokenOfOwnerByIndex/?owner={{owner}}&index={{index}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"tokenOfOwnerByIndex",
								""
							],
							"query": [
								{
									"key": "owner",
									"value": "{{owner}}"
								},
								{
									"key": "index",
									"value": "{{index}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Count all NFTs assigned to an owner",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "7d6ee035-d7f5-4260-87db-8b502b27745d",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"owner\"), 20)) {",
									"        pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"    } else {",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(uintVerify(response[\"balance\"])).to.eql(true);",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/balanceOf/?owner={{owner}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"balanceOf",
								""
							],
							"query": [
								{
									"key": "owner",
									"value": "{{owner}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Find the owner of an NFT",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "11d53a89-8c1c-447a-abb0-427c32b38a39",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(uintVerify(pm.variables.get(\"tokenId\"))){",
									"        pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"    } else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof bytesVerify(response[\"owner\"], 20)).to.eql(\"boolean\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/ownerOf/?tokenId={{tokenId}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"ownerOf",
								""
							],
							"query": [
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Transfers the ownership of an NFT from one address to another address",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "1a93b709-5feb-439e-9337-2c3c4704be72",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data\",",
									"\t return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code\",",
									"    proposed = proposed.toLowerCase()",
									"\tflag = (proposed.slice(0,2) == \"0x\")",
									"\tfor(i = 2;  i < proposed.length; i ++) {",
									"\t\ttest = proposed.charAt(i)",
									"\t\tflag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"\t}",
									"    return flag",
									"}",
									"function authVerify(authArray) {",
									"\tif((authArray.length != 4) ||",
									"\t\t(!bytesVerify(authArray[0], 32)) ||",
									"\t\t(!bytesVerify(authArray[1], 1)) ||",
									"\t\t(!bytesVerify(authArray[2], 32)) ||",
									"\t\t(!bytesVerify(authArray[3], 32)))",
									"\t{",
									"\t\treturn false;",
									"\t}",
									"\telse {",
									"\t    return true",
									"\t}",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"\tlet auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"\t\t\t\t\t\t\t\t\t ",
									"\tif(bytesVerify(pm.variables.get(\"from\"),20) && (bytesVerify(pm.variables.get(\"to\"),20)) && bytesVerify(pm.variables.get(\"tokenId\"), 32) && authVerify(auth)){",
									"\t\tpm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"\t}",
									"\telse {",
									"\t\tpm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"\t}",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/nft/safeTransferFrom/?from={{from}}&to={{to}}&tokenId={{tokenId}}&extraData={{extraData}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"safeTransferFrom",
								""
							],
							"query": [
								{
									"key": "from",
									"value": "{{from}}"
								},
								{
									"key": "to",
									"value": "{{to}}"
								},
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								},
								{
									"key": "extraData",
									"value": "{{extraData}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Transfer ownership of an NFT without safety checks",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "5c81d9cd-677e-4e23-aec9-9d4666a3739f",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"from\"),20) && (bytesVerify(pm.variables.get(\"to\"),20)) && bytesVerify(pm.variables.get(\"tokenId\"), 32) && authVerify(auth)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/nft/transferFrom/?from={{from}}&to={{to}}&tokenId={{tokenId}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"transferFrom",
								""
							],
							"query": [
								{
									"key": "from",
									"value": "{{from}}"
								},
								{
									"key": "to",
									"value": "{{to}}"
								},
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						},
						"description": "Allows Freight Trust to tranfer tokens unsafely -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST"
					},
					"response": []
				},
				{
					"name": "Change or reaffirm the approved address for an NFT",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "95f33a28-ec18-4ffd-b7c2-de6ba60f8040",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"approved\"),20) && bytesVerify(pm.variables.get(\"tokenId\"), 32) && authVerify(auth)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/nft/approve/?approved={{approved}}&tokenId={{tokenId}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"approve",
								""
							],
							"query": [
								{
									"key": "approved",
									"value": "{{approved}}"
								},
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Allows Freight Trust to issue univeral approval",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "6346c4da-3d99-42cf-b6a2-c5360d398d74",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if((typeof pm.variables.get(\"status\") == \"boolean\") && bytesVerify(pm.variables.get(\"operator\"),20)  && authVerify(auth)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/nft/setApprovalForAll/?operator={{operator}}&status={{status}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"setApprovalForAll",
								""
							],
							"query": [
								{
									"key": "operator",
									"value": "{{operator}}"
								},
								{
									"key": "status",
									"value": "{{status}}"
								}
							]
						},
						"description": "Enable or disable approval for a third party (`operator`) to manage all of Freight Trust's assets"
					},
					"response": []
				},
				{
					"name": "Get the approved address for a single NFT",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "b2adc7c5-bd0a-4560-9c35-8087465d08e3",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(uintVerify(pm.variables.get(\"tokenId\"))){",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof bytesVerify(response[\"approved\"], 20)).to.eql(\"boolean\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/getApproved/?tokenId={{tokenId}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"getApproved",
								""
							],
							"query": [
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						},
						"description": "The approved address for this NFT, or the zero address if there is none"
					},
					"response": []
				},
				{
					"name": "Query if an address is an authorized operator for another address",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "d795c29f-d9ae-4e61-aa6a-c367053049de",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"operator\"),20)){",
									"        if(bytesVerify(pm.variables.get(\"owner\"),20)){",
									"          pm.response.to.have.status(200);",
									"        }",
									"        else{",
									"          pm.expect(pm.response.code).to.be.oneOf([400, 425])  ",
									"        }",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425])",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof response[\"isApprovedForAll\"]).to.eql(\"boolean\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/nft/isApprovedForAll/?owner={{owner}}&operator={{operator}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"isApprovedForAll",
								""
							],
							"query": [
								{
									"key": "owner",
									"value": "{{owner}}"
								},
								{
									"key": "operator",
									"value": "{{operator}}"
								}
							]
						},
						"description": "True if `operator` is an approved operator for `owner`, false otherwise"
					},
					"response": []
				},
				{
					"name": "Signed Transfer",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "fbbf30cb-e1b8-4c09-9a9f-0da8b2c5afaa",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let authBA = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    let authS = [pm.variables.get(\"hash1\"), pm.variables.get(\"v1\"), pm.variables.get(\"r1\") , pm.variables.get(\"s1\")]",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"from\"),20) && (bytesVerify(pm.variables.get(\"to\"),20)) && bytesVerify(pm.variables.get(\"tokenId\"), 32) && authVerify(authBA) && authVerify(authS)){",
									"       ",
									"        extraData = pm.variables.get(\"data\")",
									"        if((extraData.length%2 === 0) && bytesVerify(extraData, extraData.length/2 - 1)){",
									"          pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"        }",
									"        else{",
									"          pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"        }",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : {\n  \t\"blockArrayAuth\" : {\n  \t\t\"sig\": \"{{sig}}\"\n  \t\t\n  \t}, \"senderAuth\" : {\n  \t\t\"sig\": \"{{sig1}}\"\n  \t}\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/nft/signedTransfer/?from={{from}}&to={{to}}&tokenId={{tokenId}}&data={{data}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"signedTransfer",
								""
							],
							"query": [
								{
									"key": "from",
									"value": "{{from}}"
								},
								{
									"key": "to",
									"value": "{{to}}"
								},
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								},
								{
									"key": "data",
									"value": "{{data}}"
								}
							]
						},
						"description": "Allows Freight Trust to sign and transfer a ERC721 token on the behalf of its holder"
					},
					"response": []
				},
				{
					"name": "Creates a new record",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "2fb45d54-e6bb-4585-92d2-f4d9862171d8",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let authBA = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    let authOW = [pm.variables.get(\"hash1\"), pm.variables.get(\"v1\"), pm.variables.get(\"r1\") , pm.variables.get(\"s1\")];",
									"    let authP = [pm.variables.get(\"hash2\"), pm.variables.get(\"v2\"), pm.variables.get(\"r2\") , pm.variables.get(\"s2\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"recordID\"),32) && (bytesVerify(pm.variables.get(\"owner\"),20)) && bytesVerify(pm.variables.get(\"participant\"), 20) && authVerify(authBA) && authVerify(authOW) && authVerify(authP)){",
									"       ",
									"         pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : {\n  \t\"blockArrayAuth\" : {\n  \t\t\"sig\": \"{{sig}}\"\n  \t}, \n  \t\"ownerAuth\" : {\n  \t\t\"sig\": \"{{sig1}}\"\n  \t}, \"partAuth\" : {\n  \t\t\"sig\": \"{{sig2}}\"\n  \t}\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/nft/createRecord/?recordID={{recordID}}&owner={{owner}}&participant={{participant}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"createRecord",
								""
							],
							"query": [
								{
									"key": "recordID",
									"value": "{{recordID}}"
								},
								{
									"key": "owner",
									"value": "{{owner}}"
								},
								{
									"key": "participant",
									"value": "{{participant}}"
								}
							]
						},
						"description": "Allows Freight Trust to create a record with the signature of the owner and of the participant."
					},
					"response": []
				},
				{
					"name": "Versions a record for Freight Trust",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "252c345d-d396-4323-a1a3-f828ae536eb1",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"currentHash\"),32) && bytesVerify(pm.variables.get(\"newHash\"),32) && authVerify(auth)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/nft/versionRecord/?currentHash={{currentHash}}&newHash={{newHash}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"versionRecord",
								""
							],
							"query": [
								{
									"key": "currentHash",
									"value": "{{currentHash}}"
								},
								{
									"key": "newHash",
									"value": "{{newHash}}"
								}
							]
						},
						"description": "Allows Freight Trust to version one of the records they own."
					},
					"response": []
				},
				{
					"name": "Versions a record for the owner",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "6e7c53c3-d70f-4f35-9b27-72da8c57d1d3",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let authBA = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"currentHash\"),32) && bytesVerify(pm.variables.get(\"newHash\"),32) && bytesVerify(pm.variables.get(\"owner\"),20) && authVerify(authBA)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : {\n  \t\"blockArrayAuth\" : {\n  \t\t\"sig\": \"{{sig}}\"\n  \t}, \"ownerAuth\" : {\n  \t\t\"sig\": \"{{sig1}}\"\n  \t\t\n  \t}\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/nft/versionRecord/signed/?currentHash={{currentHash}}&newHash={{newHash}}&owner={{owner}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"nft",
								"versionRecord",
								"signed",
								""
							],
							"query": [
								{
									"key": "currentHash",
									"value": "{{currentHash}}"
								},
								{
									"key": "newHash",
									"value": "{{newHash}}"
								},
								{
									"key": "owner",
									"value": "{{owner}}"
								}
							]
						},
						"description": "Allows Freight Trust to version a record for the owner using the owner's signature."
					},
					"response": []
				}
			],
			"description": "Folder for nft",
			"protocolProfileBehavior": {}
		},
		{
			"name": "proxy",
			"item": [
				{
					"name": "Gets address of Function",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "dbd0e361-6e95-422a-8809-12a9622ce1dc",
								"type": "text/javascript",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"id\"), 4)){",
									"        pm.response.to.have.status(200);",
									"    }else{",
									"        pm.response.to.have.status(400);",
									"    }",
									"});",
									"pm.test(\"Returns Valid Data Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(bytesVerify(response[\"target\"], 20)).to.eql(true);",
									"    }else{",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }",
									"});"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/proxy/getTarget/?id={{id}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"proxy",
								"getTarget",
								""
							],
							"query": [
								{
									"key": "id",
									"value": "{{id}}"
								}
							]
						},
						"description": "Gets address that is delegate called to run a function's logic."
					},
					"response": []
				},
				{
					"name": "Gets address of the Master Contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "7d77bfb9-ae08-45e4-8a44-bceb09eaa4d2",
								"type": "text/javascript",
								"exec": [
									"tests[\"Status code is 200\"] = responseCode.code === 200;",
									"",
									"pm.test(\"Returns Valid Data Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(bytesVerify(response[\"master\"], 20)).to.eql(true);",
									"    }else{",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }",
									"});",
									"",
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/proxy/getMaster",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"proxy",
								"getMaster"
							]
						},
						"description": "Gets the address of the master contract."
					},
					"response": []
				},
				{
					"name": "Gets address of the controller Contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "0805bd86-8a82-4a65-bd7c-d6cea62ddc4c",
								"exec": [
									"tests[\"Status code is 200\"] = responseCode.code === 200;",
									"",
									"pm.test(\"Returns Valid Data Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(bytesVerify(response[\"controller\"], 20)).to.eql(true);",
									"    }else{",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }",
									"});",
									"",
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/proxy/getController",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"proxy",
								"getController"
							]
						},
						"description": "Gets the address of the controler contract."
					},
					"response": []
				},
				{
					"name": "Gets address of the Universal Proxy Contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "28284fc3-8791-4bc9-830f-c4457360c130",
								"type": "text/javascript",
								"exec": [
									"tests[\"Status code is 200\"] = responseCode.code === 200;",
									"",
									"pm.test(\"Returns Valid Data Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(bytesVerify(response[\"universalProxy\"], 20)).to.eql(true);",
									"    }else{",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }",
									"});",
									"",
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json"
							}
						],
						"url": {
							"raw": "localhost:3000/proxy/getUniversalProxy",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"proxy",
								"getUniversalProxy"
							]
						},
						"description": "Gets the address of the Universal Proxy contract."
					},
					"response": []
				},
				{
					"name": "Sets the address of Function",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "18a6e14a-96a3-4ec8-902b-9e391a823b95",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray, res){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if (!bytesVerify(pm.iterationData.get(\"id\"), 4) ||",
									"        !bytesVerify(pm.iterationData.get(\"target\"), 20)) {",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425])  ",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/proxy/setTarget/?id={{id}}&target={{target}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"proxy",
								"setTarget",
								""
							],
							"query": [
								{
									"key": "id",
									"value": "{{id}}"
								},
								{
									"key": "target",
									"value": "{{target}}"
								}
							]
						},
						"description": "Sets address that is delegate called to run a function's logic. This function must be called with an signed nonce from the Freight Trust account in the https body."
					},
					"response": []
				},
				{
					"name": "Sets the new Master Address",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "52449761-ea57-4994-94fb-ee7b45a09f66",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(!bytesVerify(pm.iterationData.get(\"newMaster\"), 20)){",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);    ",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/proxy/changeMaster/?newMaster={{newMaster}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"proxy",
								"changeMaster",
								""
							],
							"query": [
								{
									"key": "newMaster",
									"value": "{{newMaster}}"
								}
							]
						},
						"description": "Sets address that is delegate called to run a function's logic. This function must be called with an signed nonce from the Freight Trust account in the https body."
					},
					"response": []
				},
				{
					"name": "Sets the the new controller address",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "db61ac0b-ee14-40ae-aa0b-8b525d54af06",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(!bytesVerify(pm.iterationData.get(\"newController\"), 20)){",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/proxy/changeController/?newController={{newController}}",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"proxy",
								"changeController",
								""
							],
							"query": [
								{
									"key": "newController",
									"value": "{{newController}}"
								}
							]
						},
						"description": "Sets the new controller address."
					},
					"response": []
				},
				{
					"name": "Pauses the execution",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "0500d753-a716-481f-8f93-ad5c20e7dee4",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if (!bytesVerify(pm.variables.get('sig'), 65)) {",
									"        pm.response.to.have.status(400);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "c995565a-aa88-41bf-8832-505cc6c9e421",
								"exec": [
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json",
								"disabled": true
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}",
							"options": {
								"raw": {}
							}
						},
						"url": {
							"raw": "localhost:3000/proxy/pause",
							"host": [
								"localhost"
							],
							"port": "3000",
							"path": [
								"proxy",
								"pause"
							]
						},
						"description": "Calls the pause method in the universal proxy, blocking any state changes while Blockarray updates."
					},
					"response": []
				}
			],
			"description": "Folder for proxy",
			"protocolProfileBehavior": {}
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"id": "f806767d-fa1a-40c5-a388-bfbe87589c50",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"id": "f1749be4-c70d-40b1-8c66-2f28e78b09d3",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"protocolProfileBehavior": {}
}
